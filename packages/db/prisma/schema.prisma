generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id            String    @id @default(uuid()) @db.Uuid
  name          String?
  email         String    @unique
  emailVerified DateTime?
  password      String?
  image         String?
  role          UserRole  @default(user)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts Account[]
  sessions Session[]
  testRuns TestRun[]

  @@index([email])
}

model Account {
  userId            String  @db.Uuid
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String   @db.Uuid
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

model TestRun {
  id          String     @id @default(uuid()) @db.Uuid
  userId      String     @db.Uuid
  status      TestStatus @default(Queued)
  scheduledAt DateTime?
  startedAt   DateTime?
  endedAt     DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  testConfig         TestConfig?
  testMetrics        TestMetric[]
  testResult         TestResult?
  healthCheckSummary HealthCheckSummary?

  @@index([userId, status])
  @@index([status, createdAt])
}

model TestMetric {
  id           String   @id @default(uuid()) @db.Uuid
  testRunId    String   @db.Uuid
  timestamp    DateTime @default(now())
  latency      Float
  throughput   Float
  statusCode   Int
  usersCreated Int
  p95          Float
  p99          Float
  avgRequest   Float
  maxRequest   Float

  testRun TestRun @relation(fields: [testRunId], references: [id], onDelete: Cascade)

  @@index([testRunId, timestamp])
}

model TestConfig {
  id               String     @id @default(uuid()) @db.Uuid
  testRunId        String     @unique @db.Uuid
  name             String
  url              String
  method           HttpMethod @default(GET)
  region           String
  duration         Float
  requestRate      Int // TODO: remove this and use ramp up and ramp down
  requestCount     Int
  concurrencyLevel Int
  headers          Json?
  body             Json?
  createdAt        DateTime   @default(now())

  testRun TestRun @relation(fields: [testRunId], references: [id], onDelete: Cascade)

  @@index([testRunId])
}

model TestResult {
  id                 String   @id @default(uuid()) @db.Uuid
  testRunId          String   @unique @db.Uuid
  totalRequests      Int
  requestRate        Float
  avgThroughput      Float
  peakThroughput     Float
  duration           Float
  totalResponses     Int
  minResponseTime    Float
  avgResponseTime    Float
  p50ResponseTime    Float
  p95ResponseTime    Float
  p99ResponseTime    Float
  maxResponseTime    Float
  successRate        Float
  errorRate          Float
  successfulRequests Int
  failedRequests     Int
  statusCodes        Json
  logs               Json?
  createdAt          DateTime @default(now())

  testRun TestRun @relation(fields: [testRunId], references: [id], onDelete: Cascade)

  @@index([testRunId])
}

model HealthCheckResult {
  id                   String   @id @default(uuid()) @db.Uuid
  healthCheckSummaryId String   @db.Uuid
  checkId              String
  checkName            String
  metric               String
  threshold            Float
  actualValue          Float
  operator             String
  unit                 String
  passed               Boolean
  failureDetails       Json?
  createdAt            DateTime @default(now())

  healthCheckSummary HealthCheckSummary? @relation(fields: [healthCheckSummaryId], references: [id], onDelete: Cascade)

  @@index([healthCheckSummaryId, checkId])
}

model HealthCheckSummary {
  id             String            @id @default(uuid()) @db.Uuid
  testRunId      String            @unique @db.Uuid
  totalChecks    Int
  passedChecks   Int
  failedChecks   Int
  passPercentage Float
  overallStatus  HealthCheckStatus
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  testRun            TestRun             @relation(fields: [testRunId], references: [id], onDelete: Cascade)
  healthCheckResults HealthCheckResult[]

  @@index([testRunId])
}

enum UserRole {
  user
  admin
}

enum HttpMethod {
  GET
  POST
  PUT
  DELETE
}

enum TestStatus {
  Queued
  Running
  Succeeded
  Failed
  Canceled
  Timeout
}

enum HealthCheckStatus {
  PASS
  FAIL
  PARTIAL
}
